use io;

struct EmployeeStatus : Enum {
// Enums start at 0, unless otherwise stated, steps by one whole value

    // Explicit start
    @start 0;
    // Explicit step
    @step 100;

    ADMIN,    // 0
    MANAGER,  // 100
    ENTRY,    // 200
    GUEST,    // 300
}

// Structs are Compact by default, but you can also specify!
struct Employee : Compact {
// Name of Member, Type of Member
    Status: EmployeeStatus, // See Enumerations
    Name:   Char*,
    ID:     Int,
}


// Calling Employee function
Employee : impl {

    private mut ID_seed: Int = 0;

    // Creates a new Employee struct and sets all of its attributes
    // accordingly.
    // The defer keyword activates after the return statement.
    pub func new(name: Char*, status: EmployeeStatus) : Employee {
        defer ID_seed++;
        return Employee {
            Name = name,
            Status = status,
            ID = ID_seed + status;
        }
    }

    // Untyped functions provide a quick and easy way to write 
    // a function that takes in no parameters!
    // self is assumed in Untyped Member Functions
    pub func get_name : Char* {
        return self.Name;
    }

    pub fn get_id : Int {
        return self.ID;
    }

    pub fn print : None {
        io.print("Name: {self.Name}\n");
        io.print("ID: {self.ID}");
        self.Status.print();
    }
}

EmployeeStatus : impl {

    pub print : None {
        switch(self) {
        ADMIN   => io.print("Admin"); break;
        MANAGER => io.print("Manager"); break;
        ENTRY   => io.print("Entry"); break;
        GUEST   => io.print("Guest"); break;
        else    => io.print("Unknown Status"); break; // Akin to default in C
        final   => io.print("\n"); // final always runs, unless an error occurs
        }
    }

}

func Main() : Int {
    const employee : Employee = Employee.new(name: "Ashton", status: ADMIN);
    employee.print();

    return 0;
}